using System.Text;
using Eryph.GuestServices.Core;
using Eryph.GuestServices.Sockets;

namespace Eryph.GuestServices.Tool;

public static class SshConfigHelper
{
    private const string Border = "# ------ eryph guest services ------";

    // The config should be in the local (non-roaming) profile as the connection
    // only works on the specific machine.
    private static string EryphSshConfigPath => Path.Combine(
        Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
        ".eryph",
        "guest-services",
        "ssh");

    public static string CatletSshConfigPath => Path.Combine(EryphSshConfigPath, "catlet.d");

    public static string VmSshConfigPath => Path.Combine(EryphSshConfigPath, "vm.d");

    public static async Task EnsureSshConfigAsync()
    {
        var sshUserProfilePath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
            ".ssh");

        var sshConfigPath = Path.Combine(sshUserProfilePath, "config");

        var config = $"""
                       {Border}
                       # This part of the configuration has been auto-generated by
                       # the eryph guest services and should not be modified manually.
                       
                       Include {CatletSshConfigPath}\*
                       Include {VmSshConfigPath}\*
                       
                       {Border}
                       """;

        if (!File.Exists(sshConfigPath))
        {
            Directory.CreateDirectory(sshUserProfilePath);
            await File.WriteAllTextAsync(sshConfigPath, config);
            return;
        }

        var sshConfig = await File.ReadAllTextAsync(sshConfigPath);
        if (string.IsNullOrWhiteSpace(sshConfig))
        {
            await File.WriteAllTextAsync(sshConfigPath, config);
            return;
        }
        
        var configStart = sshConfig.IndexOf(Border, StringComparison.Ordinal);
        if (configStart < 0)
        {
            await File.WriteAllTextAsync(sshConfigPath, $"{config}{Environment.NewLine}{sshConfig}");
            return;
        }

        var configEnd = sshConfig.IndexOf(Border, configStart + Border.Length, StringComparison.Ordinal);
        if (configEnd < 0)
            throw new InvalidOperationException(
                "The SSH config contains a broken eryph guest services configuration. "
                + $"Please cleanup your SSH config with can be found at '{sshConfigPath}'.");

        await File.WriteAllTextAsync(
            sshConfigPath,
            sshConfig[..configStart] + config + sshConfig[(configEnd + Border.Length)..]);
    }

    public static async Task<IReadOnlyList<string>> EnsureCatletConfigAsync(
        string catletId,
        string catletName,
        string projectName,
        Guid vmId,
        string keyFilePath)
    {
        IReadOnlyList<string> aliases = [$"{catletId}.eryph.alt", $"{catletName}.{projectName}.eryph.alt"];
        if (projectName == "default")
            aliases = [..aliases, $"{catletName}.eryph.alt"];

        Directory.CreateDirectory(CatletSshConfigPath);
        await WriteConfig(
            Path.Combine(CatletSshConfigPath, $"{catletId}.config"),
            aliases,
            vmId,
            keyFilePath);

        return aliases;
    }

    public static async Task<IReadOnlyList<string>> EnsureVmConfigAsync(
        Guid vmId,
        string? alias,
        string keyFilePath)
    {
        IReadOnlyList<string> aliases = [$"{vmId}.hyper-v.alt"];
        if (!string.IsNullOrEmpty(alias))
           aliases = [alias, ..aliases];

        Directory.CreateDirectory(VmSshConfigPath);
        await WriteConfig(
            Path.Combine(VmSshConfigPath, $"{vmId}.config"),
            aliases,
            vmId,
            keyFilePath);

        return aliases;
    }

    private static async Task WriteConfig(
        string path,
        IReadOnlyList<string> aliases,
        Guid vmId,
        string keyFilePath)
    {
        var builder = new StringBuilder();

        builder.AppendLine("# This file was auto-generated by the eryph guest services and");
        builder.AppendLine("# should not be edited manually.");
        builder.AppendLine($"Host {string.Join(' ', aliases)}");
        builder.AppendLine($"    HostName {vmId}.hyper-v.alt");
        builder.AppendLine($"    User egs");
        builder.AppendLine($"    IdentityFile {keyFilePath}");
        // Explicitly disable other authentication methods. This prevents
        // the SSH client from prompting for authentication when the private
        // key is not available. Other authentication methods would not work
        // anyway as the eryph guest services only support public key authentication.
        builder.AppendLine($"    KbdInteractiveAuthentication no");
        builder.AppendLine($"    PasswordAuthentication no");
        // Disable host key checking. The connection can only be established via
        // a local Hyper-V socket which is only accessible by administrators.
        builder.AppendLine($"    StrictHostKeyChecking no");
        // Prefer the GCM ciphers as they are significantly faster in
        // Microsoft.DevTunnels.SSH. In OpenSSH 9.9, this is the default
        // anyway. Unfortunately, Windows still ships an older version which
        // prefers the CTR ciphers.
        builder.AppendLine($"    Ciphers aes128-gcm@openssh.com,aes256-gcm@openssh.com,aes128-ctr,aes192-ctr,aes256-ctr");
        // We use our own proxy command instead of hvc nc. This enables support
        // for older versions of Hyper-V as hvc nc is only available in Windows
        // 1809 or newer.
        builder.AppendLine($"    ProxyCommand egs-tool.exe proxy {vmId}");
        // builder.AppendLine($"    ProxyCommand hvc nc -t vsock {vmId} {hvPort}");
        builder.AppendLine("");
        
        await File.WriteAllTextAsync(path, builder.ToString());
    }

    public static Task CleanupCatletConfigsAsync(IList<string> catletIds) => Task.Run(() =>
    {
        if (!Directory.Exists(CatletSshConfigPath))
            return;

        var files = Directory.EnumerateFiles(CatletSshConfigPath, "*.config", SearchOption.TopDirectoryOnly);
        foreach (var file in files)
        {
            var fileName = Path.GetFileNameWithoutExtension(file);
            if (catletIds.Contains(fileName))
                continue;

            try
            {
                File.Delete(file);
            }
            catch
            {
                // Ignore error when deleting the file. We just keep an unused config file
                // which should not cause any issues.
            }
        }
    });
}

